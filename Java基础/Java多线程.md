# 多线程拾遗
## 1、常用关键字
- `synchronized`:可以保证方法或者代码块在运行时，同一时刻只有一个进程可以访问，同时它还可以保证共享变量的内存可见性。
    - 普通同步方法，锁是当前实例（this）对象
    - 静态同步方法，锁是当前类的 Class 实例,Class相关数据存储在永久代PermGen(jdk1.8的metaspace中)，全局共享，因此静态方法锁相当于类的一个全局锁，会锁所用调用该方法的线程。
    - 同步方法块，锁是括号里面的对象
        - 同步代码块：monitorenter 指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM 需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个 Monitor 与之相关联，当且一个 Monitor 被持有之后，他将处于锁定状态。线程执行到monitorenter 指令时，将会尝试获取对象所对应的 Monitor 所有权，即尝试获取对象的锁
        - 同步方法：synchronized 方法则会被翻译成普通的方法调用和返回指令如：invokevirtual、areturn指令，在 VM 字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在 Class 文件的方法表中将该方法的access_flags字段中的synchronized 标志位置设置为 1，表示该方法是同步方法，并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示 Klass 作为锁对象。
- `volitile`:当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
- `transient`:与多线程无关,主要用来修饰不用序列化的成员属性。

## 2、常用多线程类 
- `ThreadLocal`:
    - 同一线程在某地方进行设置，在随后的任意地方都可以获取到，从而可以用来保存线程上下文信息。
    - 每个线程有一个自己的ThreadLocalMap,每个线程往ThreadLocal中读写数据是线程隔离，互相之间不会影响的。
    - 使用ThreadLocal时，可能存在内存泄漏的风险，ThreadLocalMap的静态内部类Entry的key指向ThreadLocal弱引用。
    ![ThreadLocalMap](images/ThreadLocalMap.jpeg)
    弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，该对象仅仅被弱引用关联，那么就会被回收。
    当仅仅只有ThreadLocalMap中的Entry的key指向ThreadLocal的时候，ThreadLocal会进行回收。
    在ThreadLocalMap里对应的Entry的键值会变成null，但是Entry是强引用，那么Entry里面存储的Object，并没有办法进行回收。
    由于线程的生命周期很长，如果我们往ThreadLocal里面set了很大很大的Object对象，虽然set、get等等方法在特定的条件会调用进行额外的清理，
    但是ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是后续在也没有操作set、get等方法了。
    所以最佳实践，应该在我们不使用的时候，主动调用remove方法进行清理。
    ![ThreadLocal最佳实践](images/ThreadLocal.jpeg)

- `CountDownLatch`:就是一个线程等待，直到他所等待的其他线程都执行完成并且调用countDown()方法发出通知后，当前线程才可以继续执行。
- `CyclicBarrier`:所有线程都进行等待，直到所有线程都准备好进入await()方法之后，所有线程同时开始执行！
- `ConcurrentHashMap`:JDK1.7将整个Map分为N个segment分段锁(类似HashTable)，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，可以提供相同的线程安全，但是效率提升N倍，默认N为16;JDK1.8放弃了Segment的设计，采用Node+CAS+synchronized来保证并发安全，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发。
- `CopyOnWriteArrayList`:类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我们并不需要修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了
    - 读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。
    - 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。
- `ReentrantLock`:可重入锁，是一种递归无阻塞的同步机制。它可以等同于 synchronized的使用，但是 ReentrantLock 提供了比synchronized 更强大、灵活的锁机制，可以减少死锁发生的概率。

## 3、锁

1、乐观锁：适用于读多写少的情况，读数据时不上锁，写数据时限度出当前版本号，然后加锁操作（比较版本号是否和上一次的版本号一致，一致时则更新，否则要重复读-比较-写操作，基本都是通过CAS操作来实现）

2、悲观锁：写操作较多，遇到并发写的可能性高，每次读数据都认为数据有修改，每次读写数据的时候都会上锁。java中的synchronized就是悲观锁，AQS框架下的锁则是先尝试CAS乐观锁去获取锁，获取不到才会转换为悲观锁，如ReentrantLock。

3、自旋锁：如果持有所得线程能够在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间切换进入阻塞挂起状态，他们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核切换的消耗。

优点：能尽可能的减少线程阻塞，对于锁的竞争不激烈，且占用锁事件非常短的代码块性能有大幅度提升，自旋消耗的时间小于线程阻塞挂起再唤醒的操作的消耗（阻塞挂起后在唤醒导致线程会发生两次上下文切换）。

缺点：对于锁竞争激烈的情况，或者持有锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁。因为自旋锁在获取到锁之前一直都在占用CPU做无用功（自旋锁需要设定一个自旋等待的最大时间），超过自旋最大等待时间还没获取到锁，争用锁的线程会停止自旋进入阻塞状态。如果大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起的消耗，造成CPU资源浪费

4、synchronized同步锁：可以把任意一个非null的对象当作锁。属于独占式的悲观锁，同时属于接重入锁，非公平锁。

核心组件：

1).Wait Set:调用wait方法被阻塞的线程被放置在这；

2).Collention List:竞争队列，所有请求锁的线程显现被放在这个竞争队列中；

3).Entry List:Contention List中那些有资格成为候选资源的线程被移动到Entry List中；

4).OnDeck:任意时刻，最多只有一个线程正在竞争锁资源，该线程被称为OnDeck;

5).Owner:当前已经获取到锁资源的线程被称为Owner；

6).!Owner:当前释放锁的线程；

5、非公平锁：加锁时不考虑排队等待问题，直接尝试获取锁，JVM按随机，就近原则分配锁的机制则成为不公平锁，ReentrantLock在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行效率远超公平锁。

6、公平锁：锁的分配机制是公平的，加锁前检查是否有排队等待的线程，优先排队等待的线程，先被分配到锁。

7、可重入锁：也叫递归锁，指同一线程，外层函数获得锁后，内层递归函数仍然有获取该锁的代码，但不受影响在java环境下ReentrantLock和synchronized都是可重入锁。前者通过lock()与unlock()来进行加锁与解锁操作，加锁后需要手动解锁。为避免程序出现异常而无法正常解锁，使用ReentrantLock必须在finally控制块中进行解锁操作。

```java
Lock lock =new ReentrantLock();
//Lock lock =new ReentrantLock(true);//公平锁
//Lock lock =new ReentrantLock(false);//非公平锁
Condition condition = lock.newCondition();
try{
    lock.lock();//lock加锁
	condition.await();//方法等待
    //so something
    condition.signal();//方法唤醒
}catch(InterruptedException e){
    e.printStackTrace();
}finally{
    lock.unlock();
}
```



8、ReadWriteLock读写锁:在读的地方使用读锁，在写的地方使用写锁，灵活控制，在没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，由JVM自己控制。

读锁：可以多人同时读，但不能同时写

写锁：只能有一个人在写，且不能同时读

9、共享锁：允许多个线程同时获取锁，并发访问共享资源，如:ReadWriteLock。共享锁则是一种乐观锁，放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。

10、独占锁：每次只能有一个线程能持有锁，ReentrantLock就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，避免了读/读冲突,如果某个制度线程获取收，则其他度线程都只能等待，这种情况下就限制了不必要的并发性。

11、重量级锁：（多个线程同时进入临界区）synchronized通过对象内部一个监视器锁monitor实现。但是监视器所本质又依赖于底层操作系统的Mutex Lock 来实现的。而操作系统实现线程间的钱还需要从用户态转换到内核态，成本很高，转换需要较长时间。

12、轻量级锁：（多个线程交替进入临界区）

加锁：如果成功使用CAS将对象头中的Mark Word替换为指向锁记录的指针，则获得锁，失败则当前线程尝试使用自旋（循环等待）来获取锁。

解锁：当有另一个线程与该线程同步竞争时，锁会升级为重量级锁。为了防止继续自旋，一旦升级，将无法降级

13、偏向锁：（仅有一个线程进入临界区）在无多线程竞争的情况下（只有一个线程执行同步块时）某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护，尽量减少不必要的轻量级锁执行路径。轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令。

## 4、CAS（Compare And Swap）比较并交换

是用于实现多线程同步的原子指令。 它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。CAS通过调用JNI的本地代码（其他语言）实现，根据当前处理器类型来决定是否为cmpxchg指令添加lock前缀。如果程序运行在多处理器上，就位cmpxchg指令加上lock前缀（lock cmpxchg）。反之，如果程序运行在单处理器上时，就省略lock前缀。

CAS存在的问题：

1、ABA问题：如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。

2、循环时间长开销大：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

3、只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。

## 5、AQS（AbstractQueuedSynchronizer）抽象的队列同步器

AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。

AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。使用了独占式和共享式，底层使用了模板方法模式）

[AQS详解](https://mp.weixin.qq.com/s/tRPzkzVK2kQy9MGR6D0qfQ)



[参考：Java 并发多线程高频面试题](https://mp.weixin.qq.com/s/ftXU2VXUiD__eH3OsWfM3A)